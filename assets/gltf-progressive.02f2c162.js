var rt=Object.defineProperty;var nt=(o,e,t)=>e in o?rt(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var d=(o,e,t)=>(nt(o,typeof e!="symbol"?e+"":e,t),t),Ge=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)};var b=(o,e,t)=>(Ge(o,e,"read from private field"),t?t.call(o):e.get(o)),H=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},X=(o,e,t,s)=>(Ge(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t);import{B as he,M as re,a as ke,V as N,S as Ve,C as it,T as te,b as ot,I as at,c as lt,d as ut,e as dt,f as Fe,g as ct,h as ft}from"./three@0.169.11.js";import{D as ht,K as gt,M as pt,G as $e}from"./three-examples.d0f093e2.js";const mt="modulepreload",yt=function(o,e){return new URL(o,e).href},Ue={},xt=function(e,t,s){if(!t||t.length===0)return e();const n=document.getElementsByTagName("link");return Promise.all(t.map(r=>{if(r=yt(r,s),r in Ue)return;Ue[r]=!0;const i=r.endsWith(".css"),a=i?'[rel="stylesheet"]':"";if(!!s)for(let c=n.length-1;c>=0;c--){const g=n[c];if(g.href===r&&(!i||g.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${r}"]${a}`))return;const u=document.createElement("link");if(u.rel=i?"stylesheet":mt,i||(u.as="script",u.crossOrigin=""),u.href=r,document.head.appendChild(u),i)return new Promise((c,g)=>{u.addEventListener("load",c),u.addEventListener("error",()=>g(new Error(`Unable to preload CSS for ${r}`)))})})).then(()=>e())},Xe="3.3.5";globalThis.GLTF_PROGRESSIVE_VERSION=Xe;console.debug(`[gltf-progressive] version ${Xe}`);let z="https://www.gstatic.com/draco/versioned/decoders/1.5.7/",ne="https://cdn.needle.tools/static/three/0.179.1/basis2/";const wt=z,Lt=ne,Ke=new URL(z+"draco_decoder.js");Ke.searchParams.append("range","true");fetch(Ke,{method:"GET",headers:{Range:"bytes=0-1"}}).catch(o=>{console.debug(`Failed to fetch remote Draco decoder from ${z} (offline: ${typeof navigator<"u"?navigator.onLine:"unknown"})`),z===wt&&Dt("./include/draco/"),ne===Lt&&Mt("./include/ktx2/")}).finally(()=>{je()});const _t=()=>({dracoDecoderPath:z,ktx2TranscoderPath:ne});function Dt(o){z=o,F&&F[Ce]!=z?(console.debug("Updating Draco decoder path to "+o),F[Ce]=z,F.setDecoderPath(z),F.preload()):console.debug("Setting Draco decoder path to "+o)}function Mt(o){ne=o,q&&q.transcoderPath!=ne?(console.debug("Updating KTX2 transcoder path to "+o),q.setTranscoderPath(ne),q.init()):console.debug("Setting KTX2 transcoder path to "+o)}function Re(o){return je(),o?q.detectSupport(o):o!==null&&console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail"),{dracoLoader:F,ktx2Loader:q,meshoptDecoder:Le}}function Ye(o){o.dracoLoader||o.setDRACOLoader(F),o.ktx2Loader||o.setKTX2Loader(q),o.meshoptDecoder||o.setMeshoptDecoder(Le)}const Ce=Symbol("dracoDecoderPath");let F,Le,q;function je(){F||(F=new ht,F[Ce]=z,F.setDecoderPath(z),F.setDecoderConfig({type:"js"}),F.preload()),q||(q=new gt,q.setTranscoderPath(ne),q.init()),Le||(Le=pt)}const Ie=new WeakMap;function He(o,e){let t=Ie.get(o);t?t=Object.assign(t,e):t=e,Ie.set(o,t)}const Oe=$e.prototype.load;function bt(...o){const e=Ie.get(this);let t=o[0];const s=new URL(t,window.location.href);if(s.hostname.endsWith("needle.tools")){const r=(e==null?void 0:e.progressive)!==void 0?e.progressive:!0,i=e!=null&&e.usecase?e.usecase:"default";r?this.requestHeader.Accept=`*/*;progressive=allowed;usecase=${i}`:this.requestHeader.Accept=`*/*;usecase=${i}`,t=s.toString()}return o[0]=t,Oe==null?void 0:Oe.call(this,...o)}$e.prototype.load=bt;ie("debugprogressive");function ie(o){if(typeof window>"u")return!1;const t=new URL(window.location.href).searchParams.get(o);return t==null||t==="0"||t==="false"?!1:t===""?!0:t}function vt(o,e){if(e===void 0||o===void 0||e.startsWith("./")||e.startsWith("http")||e.startsWith("data:")||e.startsWith("blob:"))return e;const t=o.lastIndexOf("/");if(t>=0){const s=o.substring(0,t+1);for(;s.endsWith("/")&&e.startsWith("/");)e=e.substring(1);return s+e}return e}function Qe(){return le!==void 0||(le=/iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent),ie("debugprogressive")&&console.log("[glTF Progressive]: isMobileDevice",le)),le}let le;function Ne(){if(typeof window>"u")return!1;const o=new URL(window.location.href),e=o.hostname==="localhost"||/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(o.hostname);return o.hostname==="127.0.0.1"||e}class Ot{constructor(e=100,t={}){d(this,"maxConcurrent");d(this,"_running",new Map);d(this,"_queue",[]);d(this,"debug",!1);d(this,"tick",()=>{this.internalUpdate(),setTimeout(this.tick,10)});this.maxConcurrent=e,this.debug=t.debug??!1,window.requestAnimationFrame(this.tick)}slot(e){return this.debug&&console.debug(`[PromiseQueue]: Requesting slot for key ${e}, running: ${this._running.size}, waiting: ${this._queue.length}`),new Promise(t=>{this._queue.push({key:e,resolve:t})})}add(e,t){this._running.has(e)||(this._running.set(e,t),t.finally(()=>{this._running.delete(e),this.debug&&console.debug(`[PromiseQueue]: Promise finished now running: ${this._running.size}, waiting: ${this._queue.length}. (finished ${e})`)}),this.debug&&console.debug(`[PromiseQueue]: Added new promise, now running: ${this._running.size}, waiting: ${this._queue.length}. (added ${e})`))}internalUpdate(){const e=this.maxConcurrent-this._running.size;for(let t=0;t<e&&this._queue.length>0;t++){this.debug&&console.debug(`[PromiseQueue]: Running ${this._running.size} promises, waiting for ${this._queue.length} more.`);const{key:s,resolve:n}=this._queue.shift();n({use:r=>this.add(s,r)})}}}const St=typeof window>"u"&&typeof document>"u",Be=Symbol("needle:raycast-mesh");function ge(o){return(o==null?void 0:o[Be])instanceof he?o[Be]:null}function Pt(o,e){if((o.type==="Mesh"||o.type==="SkinnedMesh")&&!ge(o)){const s=At(e);s.userData={isRaycastMesh:!0},o[Be]=s}}function Tt(o=!0){if(o){if(ue)return;const e=ue=re.prototype.raycast;re.prototype.raycast=function(t,s){const n=this,r=ge(n);let i;r&&n.isMesh&&(i=n.geometry,n.geometry=r),e.call(this,t,s),i&&(n.geometry=i)}}else{if(!ue)return;re.prototype.raycast=ue,ue=null}}let ue=null;function At(o){const e=new he;for(const t in o.attributes)e.setAttribute(t,o.getAttribute(t));return e.setIndex(o.getIndex()),e}const J=new Array,x=ie("debugprogressive");let fe,se=-1;if(x){let e=function(){se+=1,se>=o&&(se=-1),console.log(`Toggle LOD level [${se}]`)},o=6;window.addEventListener("keyup",t=>{t.key==="p"&&e(),t.key==="w"&&(fe=!fe,console.log(`Toggle wireframe [${fe}]`));const s=parseInt(t.key);!isNaN(s)&&s>=0&&(se=s,console.log(`Set LOD level to [${se}]`))})}function Je(o){if(x&&fe!==void 0)if(Array.isArray(o))for(const e of o)Je(e);else o&&"wireframe"in o&&(o.wireframe=fe===!0)}const de=new Array;let kt=0;const Ct=Qe()?2:10;function It(o){if(de.length<Ct){const s=de.length;x&&console.warn(`[Worker] Creating new worker #${s}`);const n=Ee.createWorker(o||{});return de.push(n),n}const e=kt++%de.length;return de[e]}class Ee{constructor(e,t){d(this,"worker");d(this,"_running",[]);d(this,"_webglRenderer",null);d(this,"_debug",!1);this.worker=e,this._debug=t.debug??!1,e.onmessage=s=>{const n=s.data;switch(this._debug&&console.log("[Worker] EVENT",n),n.type){case"loaded-gltf":for(const r of this._running)if(r.url===n.result.url){Bt(n.result),r.resolve(n.result);const i=r.url;i.startsWith("blob:")&&URL.revokeObjectURL(i)}}},e.onerror=s=>{console.error("[Worker] Error in gltf-progressive worker:",s)},e.postMessage({type:"init"})}static async createWorker(e){const t=new Worker(new URL(""+new URL("loader.worker-6e061443.js",import.meta.url).href,import.meta.url),{type:"module"});return new Ee(t,e)}async load(e,t){const s=_t();let n=t==null?void 0:t.renderer;n||(this._webglRenderer??(this._webglRenderer=(async()=>{const{WebGLRenderer:u}=await xt(()=>import("./three@0.169.11.js").then(c=>c.d0),[],import.meta.url);return new u})()),n=await this._webglRenderer);const a=Re(n).ktx2Loader.workerConfig;e instanceof URL?e=e.toString():e.startsWith("file:")?e=URL.createObjectURL(new Blob([e])):!e.startsWith("blob:")&&!e.startsWith("http:")&&!e.startsWith("https:")&&(e=new URL(e,window.location.href).toString());const l={type:"load",url:e,dracoDecoderPath:s.dracoDecoderPath,ktx2TranscoderPath:s.ktx2TranscoderPath,ktx2LoaderConfig:a};return this._debug&&console.debug("[Worker] Sending load request",l),this.worker.postMessage(l),new Promise(u=>{this._running.push({url:e.toString(),resolve:u})})}}function Bt(o){var e,t,s,n,r,i,a,l,u,c,g,_,w,S,D,B;for(const O of o.geometries){const f=O.geometry,M=new he;if(M.name=f.name||"",f.index){const h=f.index;M.setIndex(Se(h))}for(const h in f.attributes){const L=f.attributes[h],A=Se(L);M.setAttribute(h,A)}if(f.morphAttributes)for(const h in f.morphAttributes){const A=f.morphAttributes[h].map(U=>Se(U));M.morphAttributes[h]=A}if(M.morphTargetsRelative=f.morphTargetsRelative??!1,M.boundingBox=new ke,M.boundingBox.min=new N((e=f.boundingBox)==null?void 0:e.min.x,(t=f.boundingBox)==null?void 0:t.min.y,(s=f.boundingBox)==null?void 0:s.min.z),M.boundingBox.max=new N((n=f.boundingBox)==null?void 0:n.max.x,(r=f.boundingBox)==null?void 0:r.max.y,(i=f.boundingBox)==null?void 0:i.max.z),M.boundingSphere=new Ve(new N((a=f.boundingSphere)==null?void 0:a.center.x,(l=f.boundingSphere)==null?void 0:l.center.y,(u=f.boundingSphere)==null?void 0:u.center.z),(c=f.boundingSphere)==null?void 0:c.radius),f.groups)for(const h of f.groups)M.addGroup(h.start,h.count,h.materialIndex);f.userData&&(M.userData=f.userData),O.geometry=M}for(const O of o.textures){const f=O.texture;let M=null;if(f.isCompressedTexture){const h=f.mipmaps,L=((g=f.image)==null?void 0:g.width)||((w=(_=f.source)==null?void 0:_.data)==null?void 0:w.width)||-1,A=((S=f.image)==null?void 0:S.height)||((B=(D=f.source)==null?void 0:D.data)==null?void 0:B.height)||-1;M=new it(h,L,A,f.format,f.type,f.mapping,f.wrapS,f.wrapT,f.magFilter,f.minFilter,f.anisotropy,f.colorSpace)}else M=new te(f.image,f.mapping,f.wrapS,f.wrapT,f.magFilter,f.minFilter,f.format,f.type,f.anisotropy,f.colorSpace),M.mipmaps=f.mipmaps,M.channel=f.channel,M.source.data=f.source.data,M.flipY=f.flipY,M.premultiplyAlpha=f.premultiplyAlpha,M.unpackAlignment=f.unpackAlignment,M.matrix=new ot(...f.matrix.elements);if(!M){console.error("[Worker] Failed to create new texture from received data. Texture is not a CompressedTexture or Texture.");continue}O.texture=M}return o}function Se(o){let e=o;if("isInterleavedBufferAttribute"in o&&o.isInterleavedBufferAttribute){const t=o.data,s=t.array,n=new at(s,t.stride);e=new lt(n,o.itemSize,s.byteOffset,o.normalized),e.offset=o.offset}else"isBufferAttribute"in o&&o.isBufferAttribute&&(e=new ut(o.array,o.itemSize,o.normalized),e.usage=o.usage,e.gpuType=o.gpuType,e.updateRanges=o.updateRanges);return e}const $t=ie("gltf-progressive-worker"),Rt=ie("gltf-progressive-reduce-mipmaps"),Pe=Symbol("needle-progressive-texture"),K="NEEDLE_progressive",P=class{constructor(e){d(this,"parser");d(this,"url");d(this,"_isLoadingMesh");d(this,"loadMesh",e=>{var s,n;if(this._isLoadingMesh)return null;const t=(n=(s=this.parser.json.meshes[e])==null?void 0:s.extensions)==null?void 0:n[K];return t?(this._isLoadingMesh=!0,this.parser.getDependency("mesh",e).then(r=>{var i;return this._isLoadingMesh=!1,r&&P.registerMesh(this.url,t.guid,r,(i=t.lods)==null?void 0:i.length,0,t),r})):null});const t=e.options.path;x&&console.log("Progressive extension registered for",t),this.parser=e,this.url=t}get name(){return K}static getMeshLODExtension(e){const t=this.getAssignedLODInformation(e);return t!=null&&t.key?this.lodInfos.get(t.key):null}static getPrimitiveIndex(e){var s;const t=(s=this.getAssignedLODInformation(e))==null?void 0:s.index;return t??-1}static getMaterialMinMaxLODsCount(e,t){const s=this,n="LODS:minmax",r=e[n];if(r!=null)return r;if(t||(t={min_count:1/0,max_count:0,lods:[]}),Array.isArray(e)){for(const a of e)this.getMaterialMinMaxLODsCount(a,t);return e[n]=t,t}if(x==="verbose"&&console.log("getMaterialMinMaxLODsCount",e),e.type==="ShaderMaterial"||e.type==="RawShaderMaterial"){const a=e;for(const l of Object.keys(a.uniforms)){const u=a.uniforms[l].value;(u==null?void 0:u.isTexture)===!0&&i(u,t)}}else if(e.isMaterial)for(const a of Object.keys(e)){const l=e[a];(l==null?void 0:l.isTexture)===!0&&i(l,t)}else x&&console.warn(`[getMaterialMinMaxLODsCount] Unsupported material type: ${e.type}`);return e[n]=t,t;function i(a,l){const u=s.getAssignedLODInformation(a);if(u){const c=s.lodInfos.get(u.key);if(c&&c.lods){l.min_count=Math.min(l.min_count,c.lods.length),l.max_count=Math.max(l.max_count,c.lods.length);for(let g=0;g<c.lods.length;g++){const _=c.lods[g];_.width&&(l.lods[g]=l.lods[g]||{min_height:1/0,max_height:0},l.lods[g].min_height=Math.min(l.lods[g].min_height,_.height),l.lods[g].max_height=Math.max(l.lods[g].max_height,_.height))}}}}}static hasLODLevelAvailable(e,t){var r;if(Array.isArray(e)){for(const i of e)if(this.hasLODLevelAvailable(i,t))return!0;return!1}if(e.isMaterial===!0){for(const i of Object.keys(e)){const a=e[i];if(a&&a.isTexture&&this.hasLODLevelAvailable(a,t))return!0}return!1}else if(e.isGroup===!0){for(const i of e.children)if(i.isMesh===!0&&this.hasLODLevelAvailable(i,t))return!0}let s,n;if(e.isMesh?s=e.geometry:(e.isBufferGeometry||e.isTexture)&&(s=e),s&&(r=s==null?void 0:s.userData)!=null&&r.LODS){const i=s.userData.LODS;if(n=this.lodInfos.get(i.key),t===void 0)return n!=null;if(n)return Array.isArray(n.lods)?t<n.lods.length:t===0}return!1}static assignMeshLOD(e,t){var s;if(!e)return Promise.resolve(null);if(e instanceof re||e.isMesh===!0){const n=e.geometry,r=this.getAssignedLODInformation(n);if(!r)return Promise.resolve(null);for(const i of J)(s=i.onBeforeGetLODMesh)==null||s.call(i,e,t);return e["LOD:requested level"]=t,P.getOrLoadLOD(n,t).then(i=>{if(Array.isArray(i)){const a=r.index||0;i=i[a]}return e["LOD:requested level"]===t&&(delete e["LOD:requested level"],i&&n!=i&&((i==null?void 0:i.isBufferGeometry)?e.geometry=i:x&&console.error("Invalid LOD geometry",i))),i}).catch(i=>(console.error("Error loading mesh LOD",e,i),null))}else x&&console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh",e);return Promise.resolve(null)}static assignTextureLOD(e,t=0){if(!e)return Promise.resolve(null);if(e.isMesh===!0){const s=e;if(Array.isArray(s.material)){const n=new Array;for(const r of s.material){const i=this.assignTextureLOD(r,t);n.push(i)}return Promise.all(n).then(r=>{const i=new Array;for(const a of r)Array.isArray(a)&&i.push(...a);return i})}else return this.assignTextureLOD(s.material,t)}if(e.isMaterial===!0){const s=e,n=[],r=new Array;if(s.uniforms&&(s.isRawShaderMaterial||s.isShaderMaterial===!0)){const i=s;for(const a of Object.keys(i.uniforms)){const l=i.uniforms[a].value;if((l==null?void 0:l.isTexture)===!0){const u=this.assignTextureLODForSlot(l,t,s,a).then(c=>(c&&i.uniforms[a].value!=c&&(i.uniforms[a].value=c,i.uniformsNeedUpdate=!0),c));n.push(u),r.push(a)}}}else for(const i of Object.keys(s)){const a=s[i];if((a==null?void 0:a.isTexture)===!0){const l=this.assignTextureLODForSlot(a,t,s,i);n.push(l),r.push(i)}}return Promise.all(n).then(i=>{const a=new Array;for(let l=0;l<i.length;l++){const u=i[l],c=r[l];u&&u.isTexture===!0?a.push({material:s,slot:c,texture:u,level:t}):a.push({material:s,slot:c,texture:null,level:t})}return a})}if(e instanceof te||e.isTexture===!0){const s=e;return this.assignTextureLODForSlot(s,t,null,null)}return Promise.resolve(null)}static assignTextureLODForSlot(e,t,s,n){return(e==null?void 0:e.isTexture)!==!0?Promise.resolve(null):n==="glyphMap"?Promise.resolve(e):P.getOrLoadLOD(e,t).then(r=>{var i,a;if(Array.isArray(r))return console.warn("Progressive: Got an array of textures for a texture slot, this should not happen..."),null;if((r==null?void 0:r.isTexture)===!0){if(r!=e&&s&&n){const l=s[n];if(l&&!x){const u=this.getAssignedLODInformation(l);if(u&&(u==null?void 0:u.level)<t)return x==="verbose"&&console.warn("Assigned texture level is already higher: ",u.level,t,s,l,r),null}if(Rt&&r.mipmaps){const u=r.mipmaps.length;r.mipmaps.length=Math.min(r.mipmaps.length,3),u!==r.mipmaps.length&&x&&console.debug(`Reduced mipmap count from ${u} to ${r.mipmaps.length} for ${r.uuid}: ${(i=r.image)==null?void 0:i.width}x${(a=r.image)==null?void 0:a.height}.`)}s[n]=r}return r}else x=="verbose"&&console.warn("No LOD found for",e,t);return null}).catch(r=>(console.error("Error loading LOD",e,r),null))}afterRoot(e){var t,s;return x&&console.log("AFTER",this.url,e),(t=this.parser.json.textures)==null||t.forEach((n,r)=>{var i;if(n!=null&&n.extensions){const a=n==null?void 0:n.extensions[K];if(a){if(!a.lods){x&&console.warn("Texture has no LODs",a);return}let l=!1;for(const u of this.parser.associations.keys())if(u.isTexture===!0){const c=this.parser.associations.get(u);(c==null?void 0:c.textures)===r&&(l=!0,P.registerTexture(this.url,u,(i=a.lods)==null?void 0:i.length,r,a))}l||this.parser.getDependency("texture",r).then(u=>{var c;u&&P.registerTexture(this.url,u,(c=a.lods)==null?void 0:c.length,r,a)})}}}),(s=this.parser.json.meshes)==null||s.forEach((n,r)=>{if(n!=null&&n.extensions){const i=n==null?void 0:n.extensions[K];if(i&&i.lods){for(const a of this.parser.associations.keys())if(a.isMesh){const l=this.parser.associations.get(a);(l==null?void 0:l.meshes)===r&&P.registerMesh(this.url,i.guid,a,i.lods.length,l.primitives,i)}}}}),null}static async getOrLoadLOD(e,t){var l,u,c,g;const s=x=="verbose",n=this.getAssignedLODInformation(e);if(!n)return x&&console.warn(`[gltf-progressive] No LOD information found: ${e.name}, uuid: ${e.uuid}, type: ${e.type}`,e),null;const r=n==null?void 0:n.key;let i;if(e.isTexture===!0){const _=e;_.source&&_.source[Pe]&&(i=_.source[Pe])}if(i||(i=P.lodInfos.get(r)),!i)x&&console.warn(`Can not load LOD ${t}: no LOD info found for "${r}" ${e.name}`,e.type,P.lodInfos);else{if(t>0){let S=!1;const D=Array.isArray(i.lods);if(D&&t>=i.lods.length?S=!0:D||(S=!0),S)return this.lowresCache.get(r)}const _=Array.isArray(i.lods)?(l=i.lods[t])==null?void 0:l.path:i.lods;if(!_)return x&&!i["missing:uri"]&&(i["missing:uri"]=!0,console.warn("Missing uri for progressive asset for LOD "+t,i)),null;const w=vt(n.url,_);if(w.endsWith(".glb")||w.endsWith(".gltf")){if(!i.guid)return console.warn("missing pointer for glb/gltf texture",i),null;const S=w+"_"+i.guid,D=await this.queue.slot(w),B=this.previouslyLoaded.get(S);if(B!==void 0){s&&console.log(`LOD ${t} was already loading/loaded: ${S}`);let h=await B.catch(A=>(console.error(`Error loading LOD ${t} from ${w}
`,A),null)),L=!1;if(h==null||(h instanceof te&&e instanceof te?(u=h.image)!=null&&u.data||(c=h.source)!=null&&c.data?h=this.copySettings(e,h):(L=!0,this.previouslyLoaded.delete(S)):h instanceof he&&e instanceof he&&((g=h.attributes.position)!=null&&g.array||(L=!0,this.previouslyLoaded.delete(S)))),!L)return h}if(!D.use)return x&&console.log(`LOD ${t} was aborted: ${w}`),null;const O=i,f=new Promise(async(h,L)=>{if($t){const m=await(await It({})).load(w);if(m.textures.length>0)for(const p of m.textures){let y=p.texture;return P.assignLODInformation(n.url,y,r,t,void 0),e instanceof te&&(y=this.copySettings(e,y)),y&&(y.guid=O.guid),h(y)}if(m.geometries.length>0){const p=new Array;for(const y of m.geometries){const I=y.geometry;P.assignLODInformation(n.url,I,r,t,y.primitiveIndex),p.push(I)}return h(p)}return h(null)}const A=new $e;Ye(A),x&&(await new Promise(T=>setTimeout(T,1e3)),s&&console.warn("Start loading (delayed) "+w,O.guid));let U=w;if(O&&Array.isArray(O.lods)){const T=O.lods[t];T.hash&&(U+="?v="+T.hash)}const C=await A.loadAsync(U).catch(T=>(console.error(`Error loading LOD ${t} from ${w}
`,T),h(null)));if(!C)return h(null);const ee=C.parser;s&&console.log("Loading finished "+w,O.guid);let R=0;if(C.parser.json.textures){let T=!1;for(const m of C.parser.json.textures){if(m!=null&&m.extensions){const p=m==null?void 0:m.extensions[K];if(p!=null&&p.guid&&p.guid===O.guid){T=!0;break}}R++}if(T){let m=await ee.getDependency("texture",R);return m&&P.assignLODInformation(n.url,m,r,t,void 0),s&&console.log('change "'+e.name+'" → "'+m.name+'"',w,R,m,S),e instanceof te&&(m=this.copySettings(e,m)),m&&(m.guid=O.guid),h(m)}else x&&console.warn("Could not find texture with guid",O.guid,C.parser.json)}if(R=0,C.parser.json.meshes){let T=!1;for(const m of C.parser.json.meshes){if(m!=null&&m.extensions){const p=m==null?void 0:m.extensions[K];if(p!=null&&p.guid&&p.guid===O.guid){T=!0;break}}R++}if(T){const m=await ee.getDependency("mesh",R);if(s&&console.log(`Loaded Mesh "${m.name}"`,w,R,m,S),m.isMesh===!0){const p=m.geometry;return P.assignLODInformation(n.url,p,r,t,0),h(p)}else{const p=new Array;for(let y=0;y<m.children.length;y++){const I=m.children[y];if(I.isMesh===!0){const $=I.geometry;P.assignLODInformation(n.url,$,r,t,y),p.push($)}}return h(p)}}else x&&console.warn("Could not find mesh with guid",O.guid,C.parser.json)}return h(null)});return this.previouslyLoaded.set(S,f),D.use(f),await f}else if(e instanceof te){s&&console.log("Load texture from uri: "+w);const D=await new dt().loadAsync(w);return D?(D.guid=i.guid,D.flipY=!1,D.needsUpdate=!0,D.colorSpace=e.colorSpace,s&&console.log(i,D)):x&&console.warn("failed loading",w),D}}return null}static assignLODInformation(e,t,s,n,r){if(!t)return;t.userData||(t.userData={});const i=new Et(e,s,n,r);t.userData.LODS=i,"source"in t&&typeof t.source=="object"&&(t.source.LODS=i)}static getAssignedLODInformation(e){var t,s;return e?(t=e.userData)!=null&&t.LODS?e.userData.LODS:"source"in e&&((s=e.source)!=null&&s.LODS)?e.source.LODS:null:null}static copySettings(e,t){return t?(x==="verbose"&&console.debug(`Copy texture settings
`,e.uuid,`
`,t.uuid),t=t.clone(),t.offset=e.offset,t.repeat=e.repeat,t.colorSpace=e.colorSpace,t.magFilter=e.magFilter,t.minFilter=e.minFilter,t.wrapS=e.wrapS,t.wrapT=e.wrapT,t.flipY=e.flipY,t.anisotropy=e.anisotropy,t.mipmaps||(t.generateMipmaps=e.generateMipmaps),t):e}};let k=P;d(k,"registerTexture",(e,t,s,n,r)=>{var a,l,u,c,g,_,w,S;if(!t){x&&console.error("!! gltf-progressive: Called register texture without texture");return}if(x){const D=((a=t.image)==null?void 0:a.width)||((u=(l=t.source)==null?void 0:l.data)==null?void 0:u.width)||0,B=((c=t.image)==null?void 0:c.height)||((_=(g=t.source)==null?void 0:g.data)==null?void 0:_.height)||0;console.log(`> gltf-progressive: register texture[${n}] "${t.name||t.uuid}", Current: ${D}x${B}, Max: ${(w=r.lods[0])==null?void 0:w.width}x${(S=r.lods[0])==null?void 0:S.height}, uuid: ${t.uuid}`,r,t)}t.source&&(t.source[Pe]=r);const i=r.guid;P.assignLODInformation(e,t,i,s,n),P.lodInfos.set(i,r),P.lowresCache.set(i,t)}),d(k,"registerMesh",(e,t,s,n,r,i)=>{var u;const a=s.geometry;if(!a){x&&console.warn("gltf-progressive: Register mesh without geometry");return}a.userData||(a.userData={}),x&&console.log("> Progressive: register mesh "+s.name,{index:r,uuid:s.uuid},i,s),P.assignLODInformation(e,a,t,n,r),P.lodInfos.set(t,i);let l=P.lowresCache.get(t);l?l.push(s.geometry):l=[s.geometry],P.lowresCache.set(t,l),n>0&&!ge(s)&&Pt(s,a);for(const c of J)(u=c.onRegisteredNewMesh)==null||u.call(c,s,i)}),d(k,"lodInfos",new Map),d(k,"previouslyLoaded",new Map),d(k,"lowresCache",new Map),d(k,"workers",[]),d(k,"_workersIndex",0),d(k,"maxConcurrent",50),d(k,"queue",new Ot(P.maxConcurrent,{debug:x!=!1}));class Et{constructor(e,t,s,n){d(this,"url");d(this,"key");d(this,"level");d(this,"index");this.url=e,this.key=t,this.level=s,n!=null&&(this.index=n)}}class we{constructor(e,t){d(this,"ready");d(this,"_resolve");d(this,"_signal");d(this,"_frame_start");d(this,"_frames_to_capture");d(this,"_resolved",!1);d(this,"_addedCount",0);d(this,"_resolvedCount",0);d(this,"_awaiting",[]);d(this,"_maxPromisesPerObject",1);d(this,"_currentFrame",0);d(this,"_seen",new WeakMap);var r;const n=Math.max(t.frames??2,2);this._frame_start=t.waitForFirstCapture?void 0:e,this._frames_to_capture=n,this.ready=new Promise(i=>{this._resolve=i}),this.ready.finally(()=>{this._resolved=!0,this._awaiting.length=0}),this._signal=t.signal,(r=this._signal)==null||r.addEventListener("abort",()=>{this.resolveNow()}),this._maxPromisesPerObject=Math.max(1,t.maxPromisesPerObject??1)}get awaitedCount(){return this._addedCount}get resolvedCount(){return this._resolvedCount}get currentlyAwaiting(){return this._awaiting.length}update(e){var t;this._currentFrame=e,this._frame_start===void 0&&this._addedCount>0&&(this._frame_start=e),((t=this._signal)!=null&&t.aborted||this._awaiting.length===0&&this._frame_start!==void 0&&e>this._frame_start+this._frames_to_capture)&&this.resolveNow()}add(e,t,s){if(this._resolved){x&&console.warn("PromiseGroup: Trying to add a promise to a resolved group, ignoring.");return}if(!(this._frame_start!==void 0&&this._currentFrame>this._frame_start+this._frames_to_capture)){if(this._maxPromisesPerObject>=1)if(this._seen.has(t)){let n=this._seen.get(t);if(n>=this._maxPromisesPerObject){x&&console.warn("PromiseGroup: Already awaiting object ignoring new promise for it.");return}this._seen.set(t,n+1)}else this._seen.set(t,1);this._awaiting.push(s),this._addedCount++,s.finally(()=>{this._resolvedCount++,this._awaiting.splice(this._awaiting.indexOf(s),1)})}}resolveNow(){var e,t;this._resolved||(t=this._resolve)==null||t.call(this,{awaited_count:this._addedCount,resolved_count:this._resolvedCount,cancelled:((e=this._signal)==null?void 0:e.aborted)??!1})}}d(we,"addPromise",(e,t,s,n)=>{n.forEach(r=>{r.add(e,t,s)})});const W=ie("debugprogressive"),Gt=ie("noprogressive"),Te=Symbol("Needle:LODSManager"),Ae=Symbol("Needle:LODState"),Q=Symbol("Needle:CurrentLOD"),E={mesh_lod:-1,texture_lod:-1};var v,G,Y,De,Z,oe,Me,j;let _e=(v=class{constructor(e,t){d(this,"renderer");d(this,"context");d(this,"projectionScreenMatrix",new Fe);d(this,"overrideLodLevel");d(this,"targetTriangleDensity",2e5);d(this,"skinnedMeshAutoUpdateBoundsInterval",30);d(this,"updateInterval","auto");H(this,G,1);d(this,"pause",!1);d(this,"manual",!1);d(this,"_newPromiseGroups",[]);d(this,"_promiseGroupIds",0);d(this,"_lodchangedlisteners",[]);H(this,Y,void 0);H(this,De,new ct);H(this,Z,0);H(this,oe,0);H(this,Me,0);H(this,j,0);d(this,"_fpsBuffer",[60,60,60,60,60]);d(this,"_sphere",new Ve);d(this,"_tempBox",new ke);d(this,"_tempBox2",new ke);d(this,"tempMatrix",new Fe);d(this,"_tempWorldPosition",new N);d(this,"_tempBoxSize",new N);d(this,"_tempBox2Size",new N);this.renderer=e,this.context={...t}}static getObjectLODState(e){return e[Ae]}static addPlugin(e){J.push(e)}static removePlugin(e){const t=J.indexOf(e);t>=0&&J.splice(t,1)}static get(e,t){if(e[Te])return console.debug("[gltf-progressive] LODsManager already exists for this renderer"),e[Te];const s=new v(e,{engine:"unknown",...t});return e[Te]=s,s}get plugins(){return J}awaitLoading(e){const t=this._promiseGroupIds++,s=new we(b(this,Z),{...e});this._newPromiseGroups.push(s);const n=performance.now();return s.ready.finally(()=>{const r=this._newPromiseGroups.indexOf(s);r>=0&&(this._newPromiseGroups.splice(r,1),Ne()&&performance.measure("LODsManager:awaitLoading",{start:n,detail:{id:t,name:e==null?void 0:e.name,awaited:s.awaitedCount,resolved:s.resolvedCount}}))}),s.ready}_postprocessPromiseGroups(){if(this._newPromiseGroups.length!==0)for(let e=this._newPromiseGroups.length-1;e>=0;e--)this._newPromiseGroups[e].update(b(this,Z))}addEventListener(e,t){e==="changed"&&this._lodchangedlisteners.push(t)}removeEventListener(e,t){if(e==="changed"){const s=this._lodchangedlisteners.indexOf(t);s>=0&&this._lodchangedlisteners.splice(s,1)}}enable(){if(b(this,Y))return;console.debug("[gltf-progressive] Enabling LODsManager for renderer");let e=0;X(this,Y,this.renderer.render);const t=this;Re(this.renderer),this.renderer.render=function(s,n){const r=t.renderer.getRenderTarget();(r==null||"isXRRenderTarget"in r&&r.isXRRenderTarget)&&(e=0,X(t,Z,b(t,Z)+1),X(t,oe,b(t,De).getDelta()),X(t,Me,b(t,Me)+b(t,oe)),t._fpsBuffer.shift(),t._fpsBuffer.push(1/b(t,oe)),X(t,j,t._fpsBuffer.reduce((a,l)=>a+l)/t._fpsBuffer.length),W&&b(t,Z)%200===0&&console.log("FPS",Math.round(b(t,j)),"Interval:",b(t,G)));const i=e++;b(t,Y).call(this,s,n),t.onAfterRender(s,n,i)}}disable(){b(this,Y)&&(console.debug("[gltf-progressive] Disabling LODsManager for renderer"),this.renderer.render=b(this,Y),X(this,Y,void 0))}update(e,t){this.internalUpdate(e,t)}onAfterRender(e,t,s){if(this.pause)return;const r=this.renderer.renderLists.get(e,0).opaque;let i=!0;if(r.length===1){const a=r[0].material;(a.name==="EffectMaterial"||a.name==="CopyShader")&&(i=!1)}if((t.parent&&t.parent.type==="CubeCamera"||s>=1&&t.type==="OrthographicCamera")&&(i=!1),i){if(Gt||(this.updateInterval==="auto"?b(this,j)<40&&b(this,G)<10?(X(this,G,b(this,G)+1),W&&console.warn("↓ Reducing LOD updates",b(this,G),b(this,j).toFixed(0))):b(this,j)>=60&&b(this,G)>1&&(X(this,G,b(this,G)-1),W&&console.warn("↑ Increasing LOD updates",b(this,G),b(this,j).toFixed(0))):X(this,G,this.updateInterval),b(this,G)>0&&b(this,Z)%b(this,G)!=0))return;this.internalUpdate(e,t),this._postprocessPromiseGroups()}}internalUpdate(e,t){var l,u;const s=this.renderer.renderLists.get(e,0),n=s.opaque;this.projectionScreenMatrix.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse);const r=this.targetTriangleDensity;for(const c of n){if(c.material&&(((l=c.geometry)==null?void 0:l.type)==="BoxGeometry"||((u=c.geometry)==null?void 0:u.type)==="BufferGeometry")&&(c.material.name==="SphericalGaussianBlur"||c.material.name=="BackgroundCubeMaterial"||c.material.name==="CubemapFromEquirect"||c.material.name==="EquirectangularToCubeUV")){W&&(c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]||(c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]=!0,console.warn("Ignoring skybox or BLIT object",c,c.material.name,c.material.type)));continue}switch(c.material.type){case"LineBasicMaterial":case"LineDashedMaterial":case"PointsMaterial":case"ShadowMaterial":case"MeshDistanceMaterial":case"MeshDepthMaterial":continue}if(W==="color"&&c.material&&!c.object.progressive_debug_color){c.object.progressive_debug_color=!0;const _=Math.random()*16777215,w=new ft({color:_});c.object.material=w}const g=c.object;(g instanceof re||g.isMesh)&&this.updateLODs(e,t,g,r)}const i=s.transparent;for(const c of i){const g=c.object;(g instanceof re||g.isMesh)&&this.updateLODs(e,t,g,r)}const a=s.transmissive;for(const c of a){const g=c.object;(g instanceof re||g.isMesh)&&this.updateLODs(e,t,g,r)}}updateLODs(e,t,s,n){var a,l;s.userData||(s.userData={});let r=s[Ae];if(r||(r=new Ft,s[Ae]=r),r.frames++<2)return;for(const u of J)(a=u.onBeforeUpdateLOD)==null||a.call(u,this.renderer,e,t,s);const i=this.overrideLodLevel!==void 0?this.overrideLodLevel:se;i>=0?(E.mesh_lod=i,E.texture_lod=i):(this.calculateLodLevel(t,s,r,n,E),E.mesh_lod=Math.round(E.mesh_lod),E.texture_lod=Math.round(E.texture_lod)),E.mesh_lod>=0&&this.loadProgressiveMeshes(s,E.mesh_lod),s.material&&E.texture_lod>=0&&this.loadProgressiveTextures(s.material,E.texture_lod,i),x&&s.material&&!s.isGizmo&&Je(s.material);for(const u of J)(l=u.onAfterUpdatedLOD)==null||l.call(u,this.renderer,e,t,s,E);r.lastLodLevel_Mesh=E.mesh_lod,r.lastLodLevel_Texture=E.texture_lod}loadProgressiveTextures(e,t,s){if(!e)return;if(Array.isArray(e)){for(const r of e)this.loadProgressiveTextures(r,t);return}let n=!1;if((e[Q]===void 0||t<e[Q])&&(n=!0),s!==void 0&&s>=0&&(n=e[Q]!=s,t=s),n){e[Q]=t;const r=k.assignTextureLOD(e,t).then(i=>{this._lodchangedlisteners.forEach(a=>a({type:"texture",level:t,object:e}))});we.addPromise("texture",e,r,this._newPromiseGroups)}}loadProgressiveMeshes(e,t){if(!e)return Promise.resolve(null);let s=e[Q]!==t;const n=e["DEBUG:LOD"];if(n!=null&&(s=e[Q]!=n,t=n),s){e[Q]=t;const r=e.geometry,i=k.assignMeshLOD(e,t).then(a=>(a&&e[Q]==t&&r!=e.geometry&&this._lodchangedlisteners.forEach(l=>l({type:"mesh",level:t,object:e})),a));return we.addPromise("mesh",e,i,this._newPromiseGroups),i}return Promise.resolve(null)}static isInside(e,t){const s=e.min,n=e.max,r=(s.x+n.x)*.5,i=(s.y+n.y)*.5;return this._tempPtInside.set(r,i,s.z).applyMatrix4(t).z<0}calculateLodLevel(e,t,s,n,r){var B,O,f,M;if(!t){r.mesh_lod=-1,r.texture_lod=-1;return}if(!e){r.mesh_lod=-1,r.texture_lod=-1;return}let a=10+1,l=!1;if(W&&t["DEBUG:LOD"]!=null)return t["DEBUG:LOD"];const u=(B=k.getMeshLODExtension(t.geometry))==null?void 0:B.lods,c=k.getPrimitiveIndex(t.geometry),g=u&&u.length>0,_=k.getMaterialMinMaxLODsCount(t.material),w=_.min_count!==1/0&&_.min_count>=0&&_.max_count>=0;if(!g&&!w){r.mesh_lod=0,r.texture_lod=0;return}g||(l=!0,a=0);const S=this.renderer.domElement.clientHeight||this.renderer.domElement.height;let D=t.geometry.boundingBox;if(t.type==="SkinnedMesh"){const h=t;if(!h.boundingBox)h.computeBoundingBox();else if(this.skinnedMeshAutoUpdateBoundsInterval>0){if(!h[v.$skinnedMeshBoundsOffset]){const A=v.skinnedMeshBoundsFrameOffsetCounter++;h[v.$skinnedMeshBoundsOffset]=A}const L=h[v.$skinnedMeshBoundsOffset];if((s.frames+L)%this.skinnedMeshAutoUpdateBoundsInterval===0){const A=ge(h),U=h.geometry;A&&(h.geometry=A),h.computeBoundingBox(),h.geometry=U}}D=h.boundingBox}if(D){const h=e;if(t.geometry.attributes.color&&t.geometry.attributes.color.count<100&&t.geometry.boundingSphere){this._sphere.copy(t.geometry.boundingSphere),this._sphere.applyMatrix4(t.matrixWorld);const p=e.getWorldPosition(this._tempWorldPosition);if(this._sphere.containsPoint(p)){r.mesh_lod=0,r.texture_lod=0;return}}if(this._tempBox.copy(D),this._tempBox.applyMatrix4(t.matrixWorld),h.isPerspectiveCamera&&v.isInside(this._tempBox,this.projectionScreenMatrix)){r.mesh_lod=0,r.texture_lod=0;return}if(this._tempBox.applyMatrix4(this.projectionScreenMatrix),this.renderer.xr.enabled&&h.isPerspectiveCamera&&h.fov>70){const p=this._tempBox.min,y=this._tempBox.max;let I=p.x,$=p.y,V=y.x,ae=y.y;const pe=2,be=1.5,me=(p.x+y.x)*.5,ye=(p.y+y.y)*.5;I=(I-me)*pe+me,$=($-ye)*pe+ye,V=(V-me)*pe+me,ae=(ae-ye)*pe+ye;const tt=I<0&&V>0?0:Math.min(Math.abs(p.x),Math.abs(y.x)),st=$<0&&ae>0?0:Math.min(Math.abs(p.y),Math.abs(y.y)),ve=Math.max(tt,st);s.lastCentrality=(be-ve)*(be-ve)*(be-ve)}else s.lastCentrality=1;const L=this._tempBox.getSize(this._tempBoxSize);L.multiplyScalar(.5),screen.availHeight>0&&S>0&&L.multiplyScalar(S/screen.availHeight),e.isPerspectiveCamera?L.x*=e.aspect:e.isOrthographicCamera;const A=e.matrixWorldInverse,U=this._tempBox2;U.copy(D),U.applyMatrix4(t.matrixWorld),U.applyMatrix4(A);const C=U.getSize(this._tempBox2Size),ee=Math.max(C.x,C.y);if(Math.max(L.x,L.y)!=0&&ee!=0&&(L.z=C.z/Math.max(C.x,C.y)*Math.max(L.x,L.y)),s.lastScreenCoverage=Math.max(L.x,L.y,L.z),s.lastScreenspaceVolume.copy(L),s.lastScreenCoverage*=s.lastCentrality,W&&v.debugDrawLine){const p=this.tempMatrix.copy(this.projectionScreenMatrix);p.invert();const y=v.corner0,I=v.corner1,$=v.corner2,V=v.corner3;y.copy(this._tempBox.min),I.copy(this._tempBox.max),I.x=y.x,$.copy(this._tempBox.max),$.y=y.y,V.copy(this._tempBox.max);const ae=(y.z+V.z)*.5;y.z=I.z=$.z=V.z=ae,y.applyMatrix4(p),I.applyMatrix4(p),$.applyMatrix4(p),V.applyMatrix4(p),v.debugDrawLine(y,I,255),v.debugDrawLine(y,$,255),v.debugDrawLine(I,V,255),v.debugDrawLine($,V,255)}let T=999;if(u&&s.lastScreenCoverage>0)for(let p=0;p<u.length;p++){const y=u[p],$=(((O=y.densities)==null?void 0:O[c])||y.density||1e-5)/s.lastScreenCoverage;if(c>0&&Ne()&&!y.densities&&!globalThis["NEEDLE:MISSING_LOD_PRIMITIVE_DENSITIES"]&&(window["NEEDLE:MISSING_LOD_PRIMITIVE_DENSITIES"]=!0,console.warn("[Needle Progressive] Detected usage of mesh without primitive densities. This might cause incorrect LOD level selection: Consider re-optimizing your model by updating your Needle Integration, Needle glTF Pipeline or running optimization again on Needle Cloud.")),$<n){T=p;break}}T<a&&(a=T,l=!0)}if(l?r.mesh_lod=a:r.mesh_lod=s.lastLodLevel_Mesh,W&&r.mesh_lod!=s.lastLodLevel_Mesh){const L=u==null?void 0:u[r.mesh_lod];L&&console.log(`Mesh LOD changed: ${s.lastLodLevel_Mesh} → ${r.mesh_lod} (density: ${(f=L.densities)==null?void 0:f[c].toFixed(0)}) | ${t.name}`)}if(w){const h="saveData"in globalThis.navigator&&globalThis.navigator.saveData===!0;if(s.lastLodLevel_Texture<0){if(r.texture_lod=_.max_count-1,W){const L=_.lods[_.max_count-1];W&&console.log(`First Texture LOD ${r.texture_lod} (${L.max_height}px) - ${t.name}`)}}else{const L=s.lastScreenspaceVolume.x+s.lastScreenspaceVolume.y+s.lastScreenspaceVolume.z;let A=s.lastScreenCoverage*4;((M=this.context)==null?void 0:M.engine)==="model-viewer"&&(A*=1.5);const C=S/window.devicePixelRatio*A;let ee=!1;for(let R=_.lods.length-1;R>=0;R--){const T=_.lods[R];if(!(h&&T.max_height>=2048)&&!(Qe()&&T.max_height>4096)&&(T.max_height>C||!ee&&R===0)){if(ee=!0,r.texture_lod=R,W&&r.texture_lod<s.lastLodLevel_Texture){const m=T.max_height;console.log(`Texture LOD changed: ${s.lastLodLevel_Texture} → ${r.texture_lod} = ${m}px 
Screensize: ${C.toFixed(0)}px, Coverage: ${(100*s.lastScreenCoverage).toFixed(2)}%, Volume ${L.toFixed(1)} 
${t.name}`)}break}}}}else r.texture_lod=0}},G=new WeakMap,Y=new WeakMap,De=new WeakMap,Z=new WeakMap,oe=new WeakMap,Me=new WeakMap,j=new WeakMap,d(v,"debugDrawLine"),d(v,"corner0",new N),d(v,"corner1",new N),d(v,"corner2",new N),d(v,"corner3",new N),d(v,"_tempPtInside",new N),d(v,"skinnedMeshBoundsFrameOffsetCounter",0),d(v,"$skinnedMeshBoundsOffset",Symbol("gltf-progressive-skinnedMeshBoundsOffset")),v);class Ft{constructor(){d(this,"frames",0);d(this,"lastLodLevel_Mesh",-1);d(this,"lastLodLevel_Texture",-1);d(this,"lastScreenCoverage",0);d(this,"lastScreenspaceVolume",new N);d(this,"lastCentrality",0)}}const We=Symbol("NEEDLE_mesh_lod"),xe=Symbol("NEEDLE_texture_lod");let ce=null;function Ze(){const o=Ut();o&&(o.mapURLs(function(e){return ze(),e}),ze(),ce==null||ce.disconnect(),ce=new MutationObserver(e=>{e.forEach(t=>{t.addedNodes.forEach(s=>{s instanceof HTMLElement&&s.tagName.toLowerCase()==="model-viewer"&&et(s)})})}),ce.observe(document,{childList:!0,subtree:!0}))}function Ut(){if(typeof customElements>"u")return null;const o=customElements.get("model-viewer");return o||(customElements.whenDefined("model-viewer").then(()=>{console.debug("[gltf-progressive] model-viewer defined"),Ze()}),null)}function ze(){if(typeof document>"u")return;document.querySelectorAll("model-viewer").forEach(e=>{et(e)})}const qe=new WeakSet;let Nt=0;function et(o){if(!o||qe.has(o))return null;qe.add(o),console.debug("[gltf-progressive] found new model-viewer..."+ ++Nt+`
`,o.getAttribute("src"));let e=null,t=null,s=null;for(let n=o;n!=null;n=Object.getPrototypeOf(n)){const r=Object.getOwnPropertySymbols(n),i=r.find(u=>u.toString()=="Symbol(renderer)"),a=r.find(u=>u.toString()=="Symbol(scene)"),l=r.find(u=>u.toString()=="Symbol(needsRender)");!e&&i!=null&&(e=o[i].threeRenderer),!t&&a!=null&&(t=o[a]),!s&&l!=null&&(s=o[l])}if(e&&t){let r=function(){if(s){let i=0,a=setInterval(()=>{if(i++>5){clearInterval(a);return}s==null||s.call(o)},300)}};console.debug("[gltf-progressive] setup model-viewer");const n=_e.get(e,{engine:"model-viewer"});return _e.addPlugin(new Wt),n.enable(),n.addEventListener("changed",()=>{s==null||s.call(o)}),o.addEventListener("model-visibility",i=>{i.detail.visible&&(s==null||s.call(o))}),o.addEventListener("load",()=>{r()}),()=>{n.disable()}}return null}class Wt{constructor(){d(this,"_didWarnAboutMissingUrl",!1)}onBeforeUpdateLOD(e,t,s,n){this.tryParseMeshLOD(t,n),this.tryParseTextureLOD(t,n)}getUrl(e){if(!e)return null;let t=e.getAttribute("src");return t||(t=e.src),t||(this._didWarnAboutMissingUrl||console.warn("No url found in modelviewer",e),this._didWarnAboutMissingUrl=!0),t}tryGetCurrentGLTF(e){return e._currentGLTF}tryGetCurrentModelViewer(e){return e.element}tryParseTextureLOD(e,t){if(t[xe]==!0)return;t[xe]=!0;const s=this.tryGetCurrentGLTF(e),n=this.tryGetCurrentModelViewer(e),r=this.getUrl(n);if(r&&s&&t.material){let a=function(l){var c,g,_;if(l[xe]==!0)return;l[xe]=!0,l.userData&&(l.userData.LOD=-1);const u=Object.keys(l);for(let w=0;w<u.length;w++){const S=u[w],D=l[S];if((D==null?void 0:D.isTexture)===!0){const B=(g=(c=D.userData)==null?void 0:c.associations)==null?void 0:g.textures;if(B==null)continue;const O=s.parser.json.textures[B];if(!O){console.warn("Texture data not found for texture index "+B);continue}if((_=O==null?void 0:O.extensions)!=null&&_[K]){const f=O.extensions[K];f&&r&&k.registerTexture(r,D,f.lods.length,B,f)}}}};const i=t.material;if(Array.isArray(i))for(const l of i)a(l);else a(i)}}tryParseMeshLOD(e,t){var i,a;if(t[We]==!0)return;t[We]=!0;const s=this.tryGetCurrentModelViewer(e),n=this.getUrl(s);if(!n)return;const r=(a=(i=t.userData)==null?void 0:i.gltfExtensions)==null?void 0:a[K];if(r&&n){const l=t.uuid;k.registerMesh(n,l,t,0,r.lods.length,r)}}}function zt(...o){let e,t,s,n;switch(o.length){case 2:[s,t]=o,n={};break;case 3:[s,t,n]=o;break;case 4:[e,t,s,n]=o;break;default:throw new Error("Invalid arguments")}Re(t),Ye(s),He(s,{progressive:!0,...n==null?void 0:n.hints}),s.register(i=>new k(i));const r=_e.get(t);return(n==null?void 0:n.enableLODsManager)!==!1&&r.enable(),r}Ze();if(!St){const o={gltfProgressive:{useNeedleProgressive:zt,LODsManager:_e,configureLoader:He,getRaycastMesh:ge,useRaycastMeshes:Tt}};if(!globalThis.Needle)globalThis.Needle=o;else for(const e in o)globalThis.Needle[e]=o[e]}export{_e as L,k as N,xt as _,Mt as a,Ye as b,Re as c,He as d,ge as g,Dt as s};
